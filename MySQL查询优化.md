# MySQL查询优化
## 为什么要使用索引？
在不使用索引的情况，查询数据需要逐行扫描，在数据量很大的情况必然会很浪费时间。而使用索引后，通过索引能够得知匹配数据的位置，大大提高查询效率。
<div align=center>
  <img src="https://github.com/qinchunabng/ReadingNotes/blob/master/images/table_ad.png" alt="没有索引的数据表ad" title="没有索引的数据表ad"/>
  <p>没有索引的数据表ad</p>
</div>
上图是一个数据表ad，如果在没有索引的情况下，查找所有company_num为13的数据行，就需要检索表中所有的数据行，如果表很大但是仅有几个记录与搜索条件匹配，那么整个过程就很慢效率很低。但是我们如果在company_num列上建立一个索引，就不用再一行一行检索表中所有的数据行，如果查询company_num为13的行数，当搜索到company_num为14数据时，就知道后面已经没有company_num为13的数据了，这样就是提高检索效率。
这是单表查询的情况下，还有一种情况是多表联合查询，也可以通过索引的方式提高检索效率。单表里面在没有索引情况需求检索表里面所有数据行，也就是表的数据总行数，但是在多表联合查询的情况下，没有索引的情况检索的数据就是多个表中数据的笛卡尔积，这个数量将会是非常庞大的。举个栗子：假如有三个没有索引的表t1、t2和t3，且每个表中都有一列从1到1000的数据，要找出这些表所有具有相同数值所有数据行的组合，查询语句如下
<pre>
  <code>
    select * from t1 inner join t2 on t1.i1=t2.i2 inner join t2.i2=t3.i3
  </code>
</pre>
如果不用索引不全表扫面，就无法知道那些数据行包含有哪些数据。因此，必须组合所有的数据行来查找那些数据行与where字句匹配，这样的组合有1000x1000x1000种，比匹配的数据多100万倍，这是一种极大的浪费。使用索引后，查询过程将分为以下几个步骤：

1. 从数据表t1中选择第一行数据，看这个数据包含什么样的值；
2. 对数据表t2使用索引，直接找到与表t1相匹配的数据行，类似的表t3也是采用同样的操作；
3. 对数据表t1重复上面的过程，直到检查完t1表中的所有数据。

在这个例子中，虽然仍然对t1表进行了全表扫描，但是我们能对t2和t3表使用索引检索，直接将相应的数据行找出来，这种查询方式比不使用索引快100万倍。
## 索引使用方式有以下几种。
- 如上所述，索引的用途，一是在查询操作中把与WHERE子句中所给出的条件相匹配的数据行快速找出；二是关联查询中把其他表中相应的数据行快速找出。
- 对于使用MIN()或MAX()的函数查询，可以快速获取到相应值，而不用逐行检索的方式获取最大最小值。
- 使用索引快速完成ORDER BY子句和GROUP BY子句的排序和分组操作。
- 通过通过索引避免为一个整体查询数据行。假如你是查询MyISAM数据表的一个有索引的字段的值，在这种情况下，MySQL从这个索引文件读取索引值时，就已经得到了这个值，避免读取数据文件，减少了一次查询。
## 索引的缺点
- 首先，索引加快了查询速度，但是却降低了在有索引的数据里插入、删除、修改数据的速度。之所以出现这种情况，是因为写入一条数据，不仅要求将数据写入到数据行，还会改变当前的索引，一个表索引越多，写入操作也就越慢。
- 索引会占据磁盘空间，索引越多，占用的磁盘空间就越大。
  - 对于MyISAM类型数据表而言，大量的索引一个数据表，有可能导致索引文件比数据文件更快的达到它的最大值。
  - 存储在InnDB共享表空间里的全部InnoDB数据表分享着同一个存储空间，添加索引会使存储空间中用于数据存储的空间减少。和MyISAM不同，InnoDB共享表空间不受操作系统文件尺寸的大小限制，因为它可以包含多个文件。如果你有一个附加磁盘空间，你可以通过添加新的文件来扩充表空间。使用单独表空间的InnoDB数据表把数据文件和索引文件存在一个文件中，增加索引将导致文件大小更快的达到最大限制文件大小。

综上所述，如果不需要某个索引来加快查询速度，就不要创建它。
## 什么样的列适合建索引？
- **尽量为用来搜索、分类或分组的数据列创建索引，不要为作为输出的显示列创建索引**。也就是说，最适合创建索引的数据列是那些WHERE子句中数据列、联结字句中的列，或者是在ORDER BY或GROUP BY子句中出现的列。
- **数据列中数据重复可能性的列**。数据重复可能大的列不适合建索引，例如记录性别的列，取值“M”和“F”，这个时候建索引用处就不大，因为不管你查哪个值都可能找到板书左右的数据行。在这种情况下，索引或者根本就不会被使用，因为当查询优化程序确定某一个值在数据表的数据行中出现的频率超过30%时，查询优化会放弃使用索引，进行全表扫描。而现在的优化更复杂，会把其他因素也考虑进去，所以这个百分比已经不是MySQL是否使用索引的唯一依据。
- **应尽量选择比较小的数据类型建立索引**。比如，如果一个MEDIUMINT数据列已足以容纳你的数据，就不要使用BIGINT。比较小数据类型有一下几个优势：
  - 小的数据类型能够更快完成比较操作，加快索引的查找。
  - 小的数据类型体积更小，减少磁盘I/O。
  - 小的数据类型意味着缓存里的索引块可以容纳更多的键值，让MySQL可以同时容纳更多的键，而这可以使MySQL不需要读取更多索引块的前提下找到键值的概率。
  
  对InnoDB而言，由于它使用的是*聚集索引*，所以让主键尽量小更有好处。*聚集索引(clustered index)* 是指把数据行和主键值保存在一起，其他的索引都是二级索引，它们保存着主键值和二级索引值。先在二级索引中找到一个主键值，再通过它找到相应的数据行。这样的话主键值就会在每一个二级索引中重复出现，如果主键值比较大的话，就会使二级索引占用更大的内存。
- **为字符串的前缀创建索引**。假如你要为一个字符串类型的列创建索引的话，应尽量给出前缀的长度。比如：有一个CHAR(200)列，大多数值的前10个或20个字符都是唯一的，就不用给这个列创建索引，仅为前面20或30个字符创建索引就行了，这样可以节省大量的空间，而且可以是查询速度更快，减少磁盘I/O。
- **重复利用最左前缀**。当你创建一个具有n个列的符合索引时，相当于创建了n个索引，因为查找到时候只要符合左前缀就能使用到索引。假如有一个数据表，表中创建了一个符合索引，符合索引包含列province(省)、city(市)以及zip(邮政编码)。索引中的顺序是以省/市/邮编的顺序存储的，那么即使你查询中只给出了省的值或者省和市的值，也会使用到索引。以下组合将使用到索引：
  ```
  province、city、zip
  province、city
  province
  ```
  MySQL不能使用没有包含最左前缀的搜索的索引。例如，按照城市和邮政编码来搜索，索引就不会生效。如果使用省和邮编来搜索（符合索引的第一列和第三列），索引  只会使用第一列。
- **不要创建过多的索引**。不要以为索引越多越好，为所有的列创建索引，这是一种错误的做法。每一个索引都会占用额外的空间，而且会影响写入速度。当你修改数据表内容时，索引会更新并重新编排，索引越多这个时间就越长。此外，MySQL在为检索生成一个执行方案时会仔细对索引进行推敲，创建过多的索引查询优化程序就加上个更多的工作。而且，当你有更多的索引时，MySQL还有可能无法选出最好的索引来使用。只保留必要的索引可以帮助查询优化程序避免造成这种错误。如果你想添加一个索引，那么你先要看这个列是否已存在与一个符合索引的第一列，如果存在则不需要再为该列创建索引。有一个列外，对于FULLTEXT索引，你搜索的每一个不同数据列集都必须有自己的索引。
- **让索引的类型与你打算进行的比较操作的类型匹配**。在创建索引时，绝大多数存储引擎会选择它们将使用的索引。比如说，InnoDB总是使用B树索引，MyISAM也是用B树索引，但在遇到空间数据类型时会改用R数索引。MEMORY存储引擎默认使用散列索引，但也支持B树索引。在选择索引时，要考虑你打算在被索引的数据列上进行什么类型的比较操作。
  - 对于散列索引，会有一个散列函数处理每一个数据列的值。结果散列值将被存入改索引并用来查询。（散列函数采用的算法会尽量为不同的输入值生成不同的散列值，使用散列索引的好处是它们之间的比较比原始值更有效率。）散列索引在使用"="或"<>"操作符进行精确比较时速度极快，但它们在查找范围操作里面表现不佳，例如下面面这些表达式：
    ```
    id < 30
    weight BETWEEN 100 AND 150
    ```
  - B数索引在使用<、<=、=、>=、>、<>、!=和BETWEEN操作符进行的精确比较或范围查找都很有效率。如果匹配模式是以一个纯字符而不是一个通配符开始的话，B树索引还可以使用LIKE操作符进行匹配操作。
有几种比较类型的操作不能使用索引。例如，如果把数据列的值传入STRCMP()等函数进行比较，索引就不会生效。数据库必须为每个数据行计算出函数值，这就排除了使用索引的可能。
- **利用“慢查询”日志找出性能差的查询**。这个日志可以帮助我找出查询效率低查询命令，如果日志经常出现某个查询命令，就应该对这个命令进行优化。
# MySQL的查询优化程序
当你发出一个查询命令，MySQL就会去分析它，并考虑它是否可以进行优化以加快查询。MySQL查询优化程序会充分的利用索引，但它同时也会使用其他的信息。例如，如果你执行以下的查询语句，不管这个数据表有多大，MySQL都会迅速的完成查询。
```
SELECT * FROM tbl_name WHERE FALSE;
```
在这个例子里面，MySQL查看WHERE子句，并且意识没有数据行可以符合查询的条件，因此根据就没有检索数据表。可以通过EXPLAIN语句来证明这一点：

![Image of mysql explain](https://github.com/qinchunabng/ReadingNotes/blob/master/images/mysql_explain.png)
## 查询优化器的工作原理
查询优化器有好几个目标，主要目标是只要可能就是用索引，并且是用条件最严格的索引尽可能的排除那些不符合查询条件的数据。查询优化器之所以这样工作是因为它从搜索范围内排除的数据行的速度越快，找到那些与搜索条件匹配的数据行的速度就越快。假定你有一个查询，它需要根据两列来查询，这两列都创建了索引：
```
SELECT col3 FROM mytable WHERE col1='some value' AND col2='some other value';
```
同时假定检验col1时有900个匹配的数据行，检验col2时有300个匹配的数据行，同时匹配的有30个数据行。如果先检验col1，就需要从900个数据行中找出与col2匹配30个数据行，如果先检验col2就只需要从300个数据行中找出与col1匹配的30个数据行，因此第二种检验方式只要较少的计算和磁盘I/O就能获得查询结果。由此可见，查询优化程序会首先检验col2，因为这样做工作量更小。
下面给出一些帮助优化程序充分使用索引的优化建议：
- **对数据表进行分析**。这将生成关于索引值分布情况的统计数据，它们可以帮助优化器对索引的使用效果进行更准确的评估。在默认情况，你把一个有索引的数据列与一个常数进行比较时，优化器会假设相关索引的值是均匀分布的。在判断是否应该把某个索引用于常数比较的时候，优化器还会对该索引进行一次快速检查以估算需要用到多少索引项。对于InnoDB和MyISAM数据表，可以主动使用ANALYSE TABLE语句让服务器对键值进行一次分析。
如果某个数据表添加数据后不再变化，只需要在加载后对它进行一次分析就够了。如果某个表经常更新，就应该时不时（根据数据更新的频繁程度决定）对它进行分析。
- **使用EXPLAIN验证优化器操作**。EXPLAIN可以告诉你给定的查询有没有使用索引。
- **像优化器提供提示或在必要时屏蔽**。在连接操作中，你可以在数据表列表中的某个表名后面利用FORCE INDEX、USE INDEX或IGNORE INDEX限定词告诉服务器你想使用哪个索引，还可以使用STRAGHT_JOIN强制优化器按照特定的顺序使用数据表。在正常情况下，MySQL优化器会按照能最快检索出数据的顺序来执行，但在少数情况MySQL优化器的选择并不一定是最优的。如果遇到这种情况，可以使用STRAGHT_JOIN覆盖优化器决定，使用STRAGHT_JOIN的连接操作类似于一个交叉查询，但它将迫使数据表按照它们在FROM子句中出现的顺序联结查询。
