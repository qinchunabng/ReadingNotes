## String类为什么是final的？
1. 确保他们不能被继承被子类改变语义。
2. 确保String创建后不能被修改，保证String的线程安全。
3. 设计为final提高执行效率，JVM不用对相关的方法在虚函数表中查询，直接定位到String类的相关方法，提高执行效率。
## MySQL中事务的实现原理？
关系型数据库的事务都有原子性(Atomicity)、一致性(Consistency)、隔离性(Isolation)、持久性(Durability)四个基本特性。
- **原子性(Atomicity)**
 事务的原子性就是事务中的一系列操作要么不执行，要么全执行。数据库在执行事务中的一系列操作时，如果其中一个操作出现错误，那么接下来的操作可能就无法执行，
 进而造成数据错误。要想保证数据的原子性就必须在发生异常时，对已执行的操作进行回滚，在MySQL中是通过回滚日志(undo log)实现的，所有事务中进行的修改会先记
 录到回滚日志中，然后再执行对应修改，那么MySQL就可以在发生错误时，根据回滚日志撤销事务中已执行的操作。回滚日志不光能在事务执行错误进行回滚操作，还是在
 服务器突然宕机或断电的情况下，在服务器重启后通过回滚日志，回滚没有执行完的事务。所以回滚日志都是在操作之前先写入磁盘中的。回滚日志是一个逻辑日志，比如
 在数据库执行一个INSERT操作，那么响应回滚日志中就是一个DELETE操作。
- **持久性(Durability)** 事务的持久性就是事务一旦提交之后，那么数据就会被写入数据库并永久的保存下来。和原子性一样，事务的持久性也是通过日志实现的，
 MySQL是通过重做日志(redo log)来实现事物的持久性的。重做日志由两部分组成，一个是内存中重做日志缓冲区，一个是磁盘中重做日志。当在一个事务中修改数据时，
 数据库会先将数据从磁盘中读取到内存中，并更新内存中缓存的数据，然后在内存中重做日志缓冲区中生成重做日志，然后当事务真正的提交时，才会将重做日志缓冲区中
 内容刷新到磁盘中，之后再将内存中的数据更新到磁盘上。
- **隔离性(Isolation)** 事务的隔离性是指事物在并行的执行过程，对于数据的可见性。事务的隔离级别从低到高分为READ UNCOMMITED、READ COMMITED、REPEATABLE READ、SERIALIZABLE。下面逐一解释四种隔离级别的含义：
  - READ UNCOMMITED：查询时不加任何锁，有可能或查询到未提交的数据（脏读）；
  - READ COMMITED:只会读已提交的数据，但是在事务中多次查询的话，如果其他事物修改了查询数据会导致前后读取的结果不一样（Non-Repeatable Read）；
  - REPEATABLE READ:可重复读，在事务中，多次读取同一行数，只会读取第一次读取结果的快照，不会出现不同的结果，但是可能会出现在事务中，其他事物修改这行数据并提交，而在事务还是根据第一次读取的结果执行一些操作，就出现幻读；
  - SERIALIZABLE:数据库将所有数据都加上锁，使事物串行化执行，这样就解决了幻读，但是这样就降低并发访问量。
事务的隔离级别越高，并发访问量越低。

事务的隔离级别的实现是通过并发控制机制对同一时间内执行的事务进行控制，限制不同的事务对同一资源的访问和更新。数据库常用的并发控制机制主要有以下几种方式：
  - **锁** 在MySQL中存在共享锁(Shared Lock)和独占锁(Exclusive Lock)两种，也叫读锁和写锁，在事务中对读的数据加读锁，对修改的数据加写锁，读锁与读锁之间不互斥，这样保证读的并发性，写锁与读锁和写锁互斥，这样保证写数据的时候其他事务不能读和写，避免出现一些不可预料的问题。
  - **MVCC** MVCC，Multi-Version Concurrency Control，多版本并发控制。MVCC在大多数情况下代替了行锁，实现了对读的非阻塞，读不加锁，读写不冲突。缺点是每行记录都需要额外的存储空间，需要做更多的行维护和检查工作。在InnoDB中存在三个隐藏的列DB_TRX_ID（插入或删除操作最后一个事务的标识符）、DB_ROLL_PTR（写入回滚段的撤消日志记录）、DB_ROW_ID（行标识（隐藏单调自增id））。
  > MVCC只在READ COMMITED 和 REPEATABLE READ 两个隔离级别下工作。READ UNCOMMITTED总是读取最新的数据行，而不是符合当前事务版本的数据行。而SERIALIZABLE 则会对所有读取的行都加锁。
  
  **SELECT** InnoDB只查找版本(DB_TRX_ID)早于当前事务版本的数据行（行的系统版本号<=事务的系统版本号,这样可以确保数据行要么是在开始之前已经存在了，要么是事务自身插入或修改过的）。行的删除版本号(DB_ROLL_PTR)要么未定义（未更新过），要么大于当前事务版本号（在当前事务开始之后更新的）。这样可以确保事务读取到的行，在事务开始之前未被删除。
  **INSERT和DELETE** InnoDB为新插入或删除的每一行保存当前系统版本号作为行版本号。
  **UPDATE** InnoDB为插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识
